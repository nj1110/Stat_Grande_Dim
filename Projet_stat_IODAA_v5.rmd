---
title: "Projet_stat_IODAA"
authors: "Anne-Cécile TOULEMONDE,Nora PICAUT,Noémie JACQUET"
date: "2023-01-20"
output:
  beamer_presentation: default
  powerpoint_presentation: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Préparartion de l'espace de travail 

#### Espace de  travail 
```{r}
setwd("~/IODAA/Cours_IODAA/STAT-GRANDE-DIM/PROJET/Data")
```

#### Installation des packages 

```{r}
install.packages("contrib.url")
install.packages("FactoMinerR")
install.packages("corrplot")
install.packages("factoextra")
install.packages("VIM")
```

```{r cars}
library(readr)
library(tidyverse)
library(corrplot)
library(FactoMineR)
library(factoextra)
library(ggplot2)
library("VIM")
library(glmnet)
```

#### Importation des données 

```{r pressure, echo=FALSE}
df = read.csv2("Table_proteome_CD_all.csv")
```

## Objectifs du projet
Etude de l'influence de la température et du stade d'imbibition sur la capacité germinative des graines à l'aide de données de protéomique pour des graines ayant subi un vieillissement artificiel immédiat (CD_0d).

**Descripteurs:** 
- température (variable qualitative à 3 modalités : *Low*, *Medium* et *Elevated*
- stade d'imbibition (variable qualitative à 3 modalités :*DS* , *EI* , *LI*

**Variable à prédire** : (variable qualitative) Capacité germinative des graines à l'aide de données de protéomique
pour des graines ayant subi un vieillissement artificiel immédiat (CD_0d).

## QUESTION 1 Analyse descriptive 
### Nombre de lignes et colonnes 
```{r}
dim(df)
```

### Apercu du jeu de données 
```{r}
head(df)
```
#### Liste des variables 
```{r}
names(df) # Liste des variables 
```
#### Type des variables 

```{r}
str(df) ## Type de colonnes 
```

#### Dispersion des variables 
Informations descriptives 
```{r}
#summary(df) 
```

### Anlayse des corrélations (variables quantitatives)
Matrice de corrélation à partor de la 7eme colonne du dataset 
```{r}
library(corrplot)
df1= df[,7:length(df)] ##On
corrplot(cor(df1))
```

### Analyse à composantes principales 
### l'ACP n'est pas suffisante: il faut attendre le 5e axe pour expliquer 70% de la variance cumulée.
### PAS TRES INTERPRETABLE L'ACP sur les protéines donc on doit faire de la sélection de variable
```{r}
res.pca = PCA(df1,graph = FALSE)
get_eigenvalue(res.pca)
fviz_pca_var(res.pca,axes=1:2)
fviz_pca_ind(res.pca,axes=1:2)
fviz_pca_var(res.pca, axes = c(1:3))
```


#### Prétraitement 
Nombre de valeurs manquantes 
```{r}
res = summary(aggr(df,sortVar = TRUE))$group
matrixplot(df,sortby = 2 )
```
Il n'y a pas de valeurs manquantes dans ce jeu de données. 

###  Analyse descriptive : HEATMAP de correlation entre les métabolites 
### on fait une heatmap des protéines pour voir si corrélées entre elles, justement on verra rien meme en acp etc d'ou la necessité de faire de la selection de variables. Plus c'est rouge plus il y a de corrélation: groupe de protéines en bas à droite corrélées entre elles, mais il y en a bcp on doit aller plus loin et faire de la sélection de variables
```{r}
df2 = df[df$treatment=="CD_0d", c(7:length(df))]
head(df2)
heatmap(abs(cor(df2)), symm=TRUE)

```


### QUESTION 2 - ANOVA 2 facteurq (temperature et imbibition
```{r}
install.packages("MultiVarSel")
library(MultiVarSel)
df4= df[df$treatment=="CD_0d", c(4,5,7:length(df))]
head(df4)
X1_df4=df4[, 1]
X2_df4=df4[, 2]
X1_df4 <- factor(as.character(X1_df4))
X2_df4 <- factor(as.character(X2_df4))
Y_4 <- as.matrix(df4[,3:length(df4)])
Y_4 <- scale(Y_4)
X4 <- model.matrix(lm(Y_4~ X1_df4 + X2_df4 + 0))
head(X4)

#Dimensions n, p,q
n=nrow(X4)
n
p=ncol(X4)
p
q=dim(Y_4)[2]
q

```


## QUESTION 3 - ANOVA 2 facteurs (temperature et imbibition): 

### tester si les colonnes des résidus sont independantes avec le test du Portmanteau test
voir si les colonnes de Y sont indépendantes - estimer les résidus Ei chapeau
pour estimer les Ei chapeaux, modèle linéaire classique. Fonction residuals
le -1 est pour enlever l'intercept. on teste les EI chapeau sont un bruit blanc contre les EI chapeaux ne sont pas un bruit blanc : test porte-manteau
```{r}
residuals=lm(as.matrix(Y_4)~X4-1)$residuals
pvalue=whitening_test(residuals)
pvalue
```
###conclusion: 
Lorsqu'on fait le whitening-test pour voir si il y a une dépendance entre les colonnes dans la matrice des résidus on obtient une p-value de 0.94 pour l'ANOVA à 2 facteurs.The p-value est supérieure à 0.05 et donc l'hypothèse que chaque ligne de E est un bruit blanc est rejetée
On a envie d'en déduire qu'il n'y a pas de dépendance entre les colonnes et qu'on n'a pas besoin de faire un blanchiement. Toutefois on va quand meme comparer les résultats que l'on obtient sans blanchir

### QUESTION 3.1 : METHODE AVEC BLANCHIEMENT 


On va  blanchir la matrice et estimer le sigma q -1/2 pour pouvoir blanchir les donnnees
puis après on aura une matrice avec des colonnes indépendantes, sur laquelle on pourra faire un lasso
on peut faire lasso. 

### ETAPE BLANCHIEMENT
pour blanchir les données : 3 facons de modéliser la dépendance et d'estimer le sigma chapeau et à chaque fois on refait le test du porte mantean. We try our different covariance modellings for the residuals and see if one manages to remove the dependence among the columns of the residuals matrix by using a Portmanteau test.  
on a envie de vectoriser on considère un Ei tilde et on veut que ce soit du bruit blanc 
(Ecrire ce qu'il a dans H0 et ce qu'on conclut)
```{r}
result=whitening_choice(residuals,c("AR1","nonparam","ARMA"),pAR=1,qMA=1)
result
```

Conclusion:
Le modèle non parametrique a la p-value la plus élevée. On sélectionne ce type de dépendance pour modeliser les residus. On calcule sigma q -1/2 en utilisant le modèle non paramétrique
On récupère les sigma chapeau grace à la fonction whitening (on  stocke juste le sigma chapeau ici avec whitening):  

### ETAPE : sigma q -1/2 
(square root of the inverse of the estimator of the covariance matrix of each row of the residuals matrix)

```{r pressure, echo=FALSE}
square_root_inv_hat_Sigma=whitening(residuals,"nonparam",pAR=1,qMA=0)
```

### ETAPE : selection de variables stability selection
On va appliquer la technique de selection de variable  
On a tout pour blanchir les données comme colonnes indépendantes, on peut les mettre les unes sous les autres = vectoriser. Quand on vectorise Y ronde=XB+E (connaître les tailles et formule de kronecker...).
(alpha = 1 pour lasso. On recupère lamda qui minimise CV, puis on fait stability selection 
(stability selection= on prend vecteur de taile nq et on le coupe en 2 nq/2 observations, on stocke le indices, on lance glmnet avec lasso et lambad de CV on stocke les beta différents de zero. On applique ici stability selection avec 100 replications (il faut faire plutot 500 replicats pour un résultat robuste). 
=> la fonction variable_selection fait tout ça 
il faut choisir un seuil où beta est selectionné à chaque dois 


Cette fonction fournit les fréquences de sélection des variables pour les différents niveaux de la variable qualitative.
```{r pressure, echo=FALSE}
Frequencies=variable_selection(Y_4,X4,square_root_inv_hat_Sigma,nb_repli=100,parallel=FALSE)
Frequencies
```

On affiche les positions des protéines sélectionnés avec une fréquence supérieure à 95%
``````{r pressure, echo=FALSE}
colnames(Frequencies)<-c('Names_of_Y','Names_of_X','frequency')
head(Frequencies)
# Here we can consider the names of Y as numerical since they correspond to the ratio m/z of the metabolites.
Frequencies$Names_of_X<-sub('X1_df4','', Frequencies$Names_of_X)
Frequencies$Names_of_Y<-as.numeric(gsub('X4','',gsub('\\.1$','',Frequencies$Names_of_Y)))
p<-ggplot(data=Frequencies[Frequencies$frequency>=0.95,], aes(x=Names_of_Y,y=Names_of_X,color=frequency))+
geom_tile(size=0.75)+scale_color_gradient2(midpoint=0.95,mid ='orange')+
theme_bw()+ylab('Levels of X')+xlab('m/z')
p
```
```



```{r pressure, echo=FALSE}
p<-ggplot(data=Frequencies[Frequencies$frequency==1,], aes(x=Names_of_Y,y=Names_of_X,color=Names_of_X))+
 geom_point(size=1)+theme_bw()+ylab('Levels of X')+xlab('m/z')
p
```
